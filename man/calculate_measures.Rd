% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/calculate_ac.R, R/calculate_measures.R
\name{calculate_activity_counts}
\alias{calculate_activity_counts}
\alias{calculate_ac}
\alias{calculate_measures}
\alias{calculate_ai}
\alias{calculate_activity_index}
\alias{calculate_flags}
\alias{calculate_n_idle}
\alias{calculate_enmo}
\alias{calculate_ai_defined}
\alias{calculate_mad}
\alias{get_sample_rate}
\alias{calculate_auc}
\alias{calculate_fast_mims}
\alias{calculate_mims}
\title{Calculate Summary Measures from Raw Accelerometer Data}
\usage{
calculate_activity_counts(
  df,
  sample_rate = NULL,
  unit = "1 min",
  verbose = TRUE,
  ...
)

calculate_ac(df, sample_rate = NULL, unit = "1 min", verbose = TRUE, ...)

calculate_measures(
  df,
  unit = "1 min",
  fix_zeros = TRUE,
  fill_in = TRUE,
  by_second = FALSE,
  trim = FALSE,
  dynamic_range = NULL,
  calculate_mims = TRUE,
  calculate_ac = TRUE,
  flag_data = TRUE,
  flags = NULL,
  ensure_all_time = TRUE,
  verbose = TRUE,
  sample_rate = NULL,
  ...
)

calculate_ai(df, unit = "1 min", ensure_all_time = TRUE, verbose = FALSE)

calculate_activity_index(
  df,
  unit = "1 min",
  ensure_all_time = TRUE,
  verbose = FALSE
)

calculate_flags(df, unit = "1 min", ensure_all_time = TRUE)

calculate_n_idle(df, unit = "1 min", ensure_all_time = TRUE)

calculate_enmo(...)

calculate_ai_defined(...)

calculate_mad(df, unit = "1 min", ensure_all_time = TRUE, verbose = FALSE)

get_sample_rate(df, sample_rate = NULL)

calculate_auc(
  df,
  unit = "1 min",
  sample_rate = NULL,
  allow_truncation = FALSE,
  ensure_all_time = TRUE,
  verbose = TRUE
)

calculate_fast_mims(
  df,
  unit = "1 min",
  dynamic_range = NULL,
  sample_rate = NULL,
  allow_truncation = TRUE,
  ensure_all_time = TRUE,
  verbose = TRUE,
  ...
)

calculate_mims(
  df,
  unit = "1 min",
  dynamic_range = c(-6, 6),
  ensure_all_time = TRUE,
  ...
)
}
\arguments{
\item{df}{An object with columns `X`, `Y`, and `Z` or an
object of class `AccData`}

\item{sample_rate}{sample rate of data, if not specified in header of object}

\item{unit}{length of time to calculate measures over.  a character string
specifying a time unit or a multiple of a unit to be rounded to.
Valid base units are `second`, `minute`, `hour`, `day`, `week`, `month`,
`bimonth`, `quarter`, `season`, `halfyear`, and `year`.
Arbitrary unique English abbreviations as in the \code{\link{period}}
constructor are allowed.}

\item{verbose}{print diagnostic messages}

\item{...}{additional arguments to pass to [MIMSunit::mims_unit]}

\item{fix_zeros}{Should \code{\link{fix_zeros}} be run before calculating
the measures?}

\item{fill_in}{if \code{fix_zeros = TRUE}, should the zeros be
filled in with the last}

\item{by_second}{Should the last observation carried forward be done
only within the same second?}

\item{trim}{if \code{fix_zeros = TRUE},
should the time course be trimmed for zero values at
the beginning and the end of the time course?
observation carried forward?}

\item{dynamic_range}{Dynamic range of the device, in gravity units}

\item{calculate_mims}{Should MIMS units be calculated?}

\item{calculate_ac}{Should Activity Counts from the \code{activityCounts}
package be calculated?}

\item{flag_data}{Should [SummarizedActigraphy::flag_qc()] be run?
It will be executed after \code{fix_zeros} before any measure
calculation}

\item{flags}{the flags to calculate,
passed to [SummarizedActigraphy::flag_qc()]}

\item{ensure_all_time}{if \code{TRUE}, then all times from the first to
last times will be in the output, even if data during that time was not
in the input}

\item{allow_truncation}{truncate small values}
}
\value{
A data set with the calculated features
}
\description{
Calculate Summary Measures from Raw Accelerometer Data
}
\examples{
file = system.file("extdata", "TAS1H30182785_2019-09-17.gt3x",
package = "SummarizedActigraphy")
res = read_actigraphy(file)
measures = calculate_measures(res, dynamic_range = NULL,
calculate_mims = FALSE)
auc = calculate_auc(res)
\donttest{
mims = calculate_mims(res, dynamic_range = NULL)
}
if (requireNamespace("data.table", quietly = TRUE)) {
   dr
   dt = data.table::as.data.table(res$data)
   out = calculate_measures(dt, calculate_mims = FALSE, flag_data = FALSE)
}

}
